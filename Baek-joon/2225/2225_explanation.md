## 백준 2225번 풀이

### 문제

*0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.*

*덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.*



### 입력

*첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.*



### 출력

*첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.*

***



### 풀이

일단 문제에서 제시된 대로 작은 경우의 수부터 계산을 해보았다.

예를 들면

input : 1 1

case : (1)

input : 2 1

case : (2)

...

input : 1 2

case : (1 0), (0 1)

input : 2 2

case : (2 0),(0 2),(1 1)

...

이런 식으로 진핸 된다. 그래서 각각의 경우의 수를 될 수 있는 만큼 구해 보았다.

```
K	K
...
4	4	10	20	
3	3	6	9
2	2	3	4	5	6
1	1	1	1	1	1	1	1	1			1
	1	2	3	4	5	6	7	8	....	N
```

이런 형태가 된다.



일단 어느 정도 똑같이 커진다는 걸 보면 규칙이 있는 것을 알 수 있는데.

`dp[i][j]= dp[i-1][1] + dp[i-1][2] + ... + dp[i-1][j]`

라는 규칙을 찾아 낼 수 있다.



그렇다면 이제 

basecase를 구한다.



1.

```pseudocode
for i=1 ...N :
	dp[i][1] = 1
```

즉,

```
1	1	1	1	1	1	1	1	1			1
	1	2	3	4	5	6	7	8	....	N
```

부분을 1로 설정한다.



2.

```pseudocode
for i=1 ... K :
	dp[1][i] = i
```

즉,

```
K	K
...
4	4
3	3
2	2
1	1
	1
```

부분을 각각 i로 설정한다



이제 점화식

```pseudocode
for i = 2 ... k :
	for j = 2 ... n :
		dp[j][i]=sum(dp[j-1][1:i+1])
```

각각 이전 배열의 자기 바로 전까지 자른 수의 총 합을 더해준다.



### 전체 코드

```python
import sys
input = sys.stdin.readline

if __name__ == '__main__' :
    n,k = map(int, input().strip().split())

    dp = [[0] * (k+1) for _ in range(n+1)]

    for i in range(1,n+1) :
        dp[i][1] = 1
    for i in range(1,k+1) :
        dp[1][i] = i

    for i in range(2,k+1) :
        for j in range(2,n+1) :
            dp[j][i]=sum(dp[j-1][1:i+1])%1000000000

    print(dp[n][k])
```

