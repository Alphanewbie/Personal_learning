## 백준 12865번 문제 풀이

https://www.acmicpc.net/problem/12865

### 문제

*이 문제는 아주 평범한 배낭에 관한 문제이다.*

*한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.*

*준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K무게까지의 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.*

### 입력

*첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.*

*입력으로 주어지는 모든 수는 정수이다.*



### 출력

*한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.*



### 풀이

knapsack 알고리즘 문제이다.

가방이 1개일 때 가치에 맞게 넣어서 최대의 이득을 보는 문제이다.

knapsack 중요한 요소는 3개인데

1. 가치
2. 무게
3. 물품의 갯수

이 중에서 구해야 하는건 가치이므로 남은 2개를 DP의 요소로 삼는다.

`dp[i][j]`

`i` 는 물품의 갯수

`j` 는 감당할 수 잇는 물품의 무게

그리고 `dp[i][j]`에 들어가는 것이 현재 i까지의 물건을 고려해봤을때 가방에 j의 무게가 남았을 때 가치를 말한다.



그럼 일단 베이스 케이스 부터 구해보자.

1. 물건이 아무것도 없을 때의 가치
2. 가방의 용량이 하나도 없을 때의 가치

```pseudocode
for i ... n :
	dp[i][0] = 0
for j ... k :
	dp[0][j] = 0
```

이것은 이중배열을 그냥 전부 0으로 초기화 시키는 것와 같다.

```pyhton
dp = [[0] * (k+1) for _ in range(n+1)]
```



이제 점화식을 생각해보면

1. 가방에 해당 물건을 넣을 수 있을 정도의 용량이 남아 있을 때
   1. 물건을 가방에 넣는다
   2. 물건을 가방에 넣지 않는다.
2. 가방에 해당 물건을 넣을 수 있을 정도의 용량이 없을 때

```pseudocode
if 가방의 용량 > item[i]의 무게 : 
	dp[i][j] = Max(dp[i - 1][j], dp[i - 1][j - item[i]의 무게] + item[i]의 가치
else
	dp[i][j] = dp[i - 1][j]
```

들어갈 수 있을때 넣을 수 있는 무게를 비교해서 더 큰 쪽을 넣는다.

```python
for i in range(1,n + 1) :
	for j in range(1,k + 1):
		if j >= item[i][0]:
			dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - item[i][0]] + item[i][1])
		else:
			dp[i][j] = dp[i - 1][j]
```







### 전체 코드

```java
import sys
input = sys.stdin.readline

if __name__ == "__main__" :
    (n,k) = map(int,input().strip().split())

    item = [[0,0]]

    for _ in range(n) :
        (m, v) = map(int,input().strip().split())
        item.append([m, v])

    dp = [[0] * (k+1) for _ in range(n+1)]

    for i in range(1,n + 1) :
        for j in range(1,k + 1):
            if j >= item[i][0]:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - item[i][0]] + item[i][1])
            else:
                dp[i][j] = dp[i - 1][j]

    print(dp[n][k])
```


