## 백준 1010 풀이

https://www.acmicpc.net/problem/1010

### 문제

재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 사이트라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 N개의 사이트가 있고 동쪽에는 M개의 사이트가 있다는 것을 알았다. (N ≤ M)

재원이는 서쪽의 사이트와 동쪽의 사이트를 다리로 연결하려고 한다. (이때 한 사이트에는 최대 한 개의 다리만 연결될 수 있다.) 재원이는 다리를 최대한 많이 지으려고 하기 때문에 서쪽의 사이트 개수만큼 (N개) 다리를 지으려고 한다. 다리끼리는 서로 겹쳐질 수 없다고 할 때 다리를 지을 수 있는 경우의 수를 구하는 프로그램을 작성하라.

![img](https://www.acmicpc.net/upload/201003/pic1.JPG)

### 입력

입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수 정수 N, M (0 < N ≤ M < 30)이 주어진다.

### 출력

각 테스트 케이스에 대해 주어진 조건하에 다리를 지을 수 있는 경우의 수를 출력한다.

***



### 풀이 전개 과정

m개 중에서 n개와 이어지는 것들을 뽑는 문제이다.

그리고 그렇게 뽑힌 n개를 왼쪽에 있는 것과 위에서부터 순서대로 연결하면 되는 문제이다.



m개 중에서 n개를 순서 상관없이 뽑는 문제이다.

즉, 조합문제이다.



하지만, 조합은 계산 공식대로 m * (m-1) * (m-2) ....n개 / 1 * 2 * 3 ....n 식으로 하면 너무 오래 걸리는데

이 문제를 해결 하기 위해 학창 시절에 배운 공식이 하나 있다.



nCr = n-1Cr-1 + n-1Cr



그렇지만 이 공식도 문제가 하나 있는데, 이미 한번 구했던 것을 다시 구하는 과정이 너무 많다는 것이다.

즉, 다이나믹 프로그래밍으로 이것을 하나하나 저장해 주면 속도의 개선을 해 줄 수 있다.



### 전체 코드

```java
import sys
input = sys.stdin.readline

dp = [[0 for i in range(31)] for i in range(31)]

def combination(n, r) :
    if dp[n][r]!=0 :
        return dp[n][r]
    if n == r or r == 0  :
        dp[n][r] = 1
        return 1;
    else :
        dp[n][r] = combination(n - 1, r - 1) + combination(n - 1, r)
        return dp[n][r]

n = int(input())

for i in range (n) :
    n,m =  map(int,input().split())

    print(combination(m,n))
```
