## 백준 1300번 풀이

https://www.acmicpc.net/problem/1300

### 문제

*세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.*

*배열 A와 B의 인덱스는 1부터 시작한다.*

### 입력

*첫째 줄에 배열의 크기 N이 주어진다. N은 105보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min(109, N2)보다 작거나 같은 자연수이다.*

### 출력

*B[k]를 출력한다.*

***

### 풀이

이분 탐색 문제이다

이 문제는 이분 탐색이라는 것을 알아내는 것 자체가 어려운 문제였다.



k번째의 숫자가 무엇인지 알아내는 문제인데, 이 문제에서 k번째의 수는 k보다 작거나 같다는 것이 확실하다는 것을 캐치하는 것이 관건이였다.

즉, 구해야 하는 result은 `1 <= result <= k`의 범위 안에 있다.

정확히는 n이 1이나 2가 아닌 경우에는 k가 무조건 result보다 크다.

왜냐하면, 1~N의 값은 일렬로 배치한다면 무조건 2개 이상은 들어가기 때문이다.



예를 들면, 위의 3의 배열을 기준으로 삼았을때,

1	2	3

2	4	6

3	6	9

이렇게 9개의 배열을 일렬로 배치할 경우

1, 2, 2, 3, 3, 4, 6, 6, 9

물론 i,j가 여러개 있긴 하지만, 일단 저렇게 있다는 것으로 result는 k보다 작다는 것을 확인할 수 있다.



그럼 여러개의 중복된 숫자가 있는 정해진 범위 안에 있는 최대값중에 최솟값을 구하는 문제, 파라매트릭 서치와 비슷하게 풀면 된다.

그럼 1~k의 숫자의 중간 값, (1+k)/2를 기준으로 찾게 된다면, 중간 값은 (1+7)/2인 4를 기준으로 찾는다.

그러면 저중에서 4보다 작거나 같은 수의 갯수를 찾는다.

**1	2	3**

**2	4**	6

**3**	6	9

총 6개 인 것을 알 수가 있다.

즉, i*j의 행렬에서 i가 고정된 열에서 k 이하의 수의 갯수는 k/i이다.

하지만, 그 N개 만큼의 수가 들어가 있으므로 min(k/i, N)이 i번째 열의 k이하의 수의 갯수이다.

7보다 작다. 즉, 구해야 되는 값인 result는 적어도 4보다 크다.

그럼 5~7의 값의 중간인 6을 기준으로 찾는다.

**1	2	3**

**2	4**	**6**

**3**	**6**	9

8개가 들어감을 알 수가 있다.

그러므로 mid의 값인 6을 저장하고, 그 밑을 당겨서 다시 탐색

5~5, 즉 5일때를 기준으로 삼아서 찾으면

**1	2	3**

**2	4**	6

**3**	6	9

6개 들어감을 알 수가 있다. 즉, k의 수는 저장된 값인 6이 된다.

``` python
import sys
input = sys.stdin.readline

if __name__ == "__main__":
    N = int(input().strip())
    k = int(input().strip())

    start = 1
    end = k
    while (end - start) >= 0:
        mid = (start + end)//2
        cnt = 0
        for i in range(1, N+1):
            cnt += min(mid//i, N)
            
        if cnt >= k:
            result = mid
            end = mid - 1
        else:
            start = mid + 1
    print(result)

```