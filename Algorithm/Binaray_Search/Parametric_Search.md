## 파라메트릭 서치

- **최적화 문제**(문제의 상황을 만족하는 특정 변수의 최솟값, 최댓값을 구하는 문제)를 **결정 문제**로 바꾸어 푸는 것
- 주어진 범위 내에서 원하는 값 또는 원하는 조건에 가장 일치하는 값을 찾아내는 알고리즘
- 보통 최대가 최소가 되는 값 이라는 식으로 등장한다.



### 예시1

https://www.acmicpc.net/problem/2512

파라매트릭 서치의 가장 대표적인 문제, 예산 문제. 줄 수 있는 예산의 최대값을 구하는 문제이다.

가지고 있는 예산이 N이고 줄 수 있는 공평하게 줄 수 있는 예산의 최대값을 구하는 문제, 하지만 돈은 0.1단위로 내려갈 수 없으므로 무조건 정수가 되어야한다. 즉, 최대의 최소값을 구하는 문제이다.

요청된 예산이 120 110 140 150일때, 가지고 있는 예산은 485일때, 최대로 줄 수 있는 예산을 구하는 문제이다.

만약 최대 예산보다 요청된 예산이 적다면 전부 주고, 만약 요청된 예산이 더 크다면 최대 예산 만큼만 주는 문제이다.



일단 최대로 줄 수 있는 예산을 주어진 예산의 최대값으로, 최소로 줄 수 있는 예산을 0으로 잡고 계산한다.

```python
min_budget = 0
max_budget = max(wants)
```

즉, 예산의 최대값은 이 두 범위의 안에 존재한다.

그러므로 두 범위 안에 존재하는 값을 찾아내는 알고리즘, 이분 탐색을 시작한다.

```python
while max_budget - min_budget >= 0:
    mid = (min_budget+max_budget)//2
    sum = 0
    for want in wants:
        sum += want if want <= mid else mid
        if sum > budget:
            break
    ...
```

하지만, 최대의 최소값을 찾는 문제이다.

```python
if sum > budget:
    max_budget = mid - 1
else:
    result = mid
    min_budget = mid + 1
```

mid 값을 기준으로 각 부서에 줄 수 있는 예산이, 주어진 예산 안에 저장을 한다면

result로 저장한다. 하지만, 예산이 초과되었다면 줄 수 있는 예산을 줄이고 다시 저장한다.



쭉 반복을 하다보면 결국 주어진 예산으로 줄 수 있는 예산의 최대값이 mid 값으로 저장되게 된다.



```python
import sys

input = sys.stdin.readline


def parametric(min_budget, max_budget, arr):
    while max_budget - min_budget >= 0:
        mid = (min_budget+max_budget)//2
        sum = 0
        for want in wants:
            sum += want if want <= mid else mid
            if sum > budget:
                break
        if sum > budget:
            max_budget = mid - 1
        else:
            result = mid
            min_budget = mid + 1
    return result


if __name__ == "__main__":
    N = int(input().strip())
    wants = list(map(int, input().strip().split()))
    budget = int(input().strip())
    wants.sort()

    print(parametric(0, wants[-1], wants))

```







### 예시2

배가 7시간마다 고파지는 사람이 하루를 배부르게 지내기 위한 최소한의 식사횟수는 몇회인지에 구하는 문제가 있다고 가정해보자.**(글에서 주어지는 예시에서는 소수점 첫째자리까지만 계산한다.)**

잠자는 시간등을 고려하지 않는다고 계산할 때 24시간을 식사횟수로 나눴을 때 7 또는 7에 가장 가까운 값이 나오도록 하는 것이 이 문제를 풀기 위한 조건이라고 할 수 있다.

0끼부터 10끼가지의 식사가 가능하다고 할 때



-첫 번째 단계

0                              5                               10 

​                               △(중간값)

범위가 0부터 10까지이므로 (0+10)/2 = 5를 중간값으로 하여 조건에 부합한지 검사해본다.

24 / 5 =4.8 이므로 원하는 값인 7보다 작다. 즉 나누는 값이 더 작아져야하므로 5 바로 밑에 있는 값인 4.9를 범위의 최댓값으로 하여 반복한다.



-두 번째 단계

0                             2.4                              4.9

​								△(중간값)

24 / 2.4 = 10 이므로 원하는 값인 7보다 크다. 따라서 이번엔 중간값이였던 2.4 바로 윗값인 2.5를 최솟값으로 하여 2.4부터 4.9까지의 범위로 다시 반복합니다.



위의 과정을 반복하다보면 탐색범위와 중간값은 0-10(5) -> 0-4.9(2.4) -> 2.5-4.9(3.7) -> 2.4-3.6(3) -> 3.1-3.6(3.3) -> 3.4-3.6(3.5) -> 3.4-3.4(3.4) -> 3.4-3.3(3.3) 으로 변화할 것이며 범위의 시작값과 끝값의 대소관계가 역전되는 순간 탐색이 종료된다. 역전되기 직전 중간값인 3.4가 구하고자 하는 값이며 24를 7로 나눴을 때의 소수점 첫째짜리까지의 값이 3.4이므로 올바르게 탐색이 되었다.



위 예시의 핵심은 배부르게 지내기 위해 하루 최소 몇 회의 식사를 먹어야 하는가? 에 대한 최적화 문제가 하루에 식사를 R번 했을 때 배부르게 지낼 수 있는가에 대한 결정 문제로 바뀌었다는 것입니다. 문제의 조건이 복잡하거나 문제의 상황상 최적화시키기 위한 프로그래밍적 구현이 어려울 때는 이 파라메트릭 서치라는 알고리즘을 떠올리고 상황에 맞게 변형하여 이용해보시면 좋을 것 같습니다



### 시간 복잡도

O(logN)







출처 : 

https://www.crocus.co.kr/1000

https://marades.tistory.com/7