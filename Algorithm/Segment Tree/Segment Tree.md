# 세그먼트 트리

주어진 쿼리에 대해 빠르게 응답하기 위해 만들어진 자료 구조.

예를 들면 1 2 3 4 5 6 이라는 배열 arr이 있었다면,

arr[2] + arr[3] + arr[4] 를 구하라는 쿼리를 요청 받고 arr[3]를 10으로 바꾸고 arr[2] + arr[3] + arr[4]를 다시 구하라는 쿼리가 오면

한번 실행하는데 걸리는 시간은

수를 바꾸는데 O(1), 수를 더하는데 O(N)이니 M번 수행한다 치면 **O(MN+M) -> O(MN)**의 시간이 걸린다.



### 세그먼트 트리의 장점

위의 식과 비교하면 세그먼트 트리는

**수를 바꾸는 과정 :: O(logN)**

**수를 더하는 과정 :: O(logN)**

M번 실행한다 치면 **O(MlongN + MlogN)-> O(MlogN)**이 걸리게 된다.



***세그먼트 트리는 대부분 완전 이진 트리이다.***



***

### 그림을 통한 세그먼트 트리 확인

![그림1](.\그림1.png)

위의 그림은 N=12일때의 모습이다.

제일 아래 **리프 노드**로 달린 것들이 **실제 우리가 처음에 받아온 데이터**들이다.

- 여기서는 0,1,2,3,4,5,6,7,8,9,10,11라고 적힌 노드들을 의미한다.

**x~y의 의미**는

**x부터 y까지의 합의 범위**를 나타낸것



즉, 최상위 루트는 입력된 모든 값의 총 합을 의미한다.



### 세그먼트 트리의 전체 크기 구하기


N = 12일 때의 **세그먼트 트리의 전체 크기(배열 사이즈 정하기)**를 구하기 위해서는 

**2^k로 12보다 바로 큰 값을 만들 수 있는 k**를 찾아야한다. 즉, k는 4이다.



그리고 난 뒤 **2^k를 하면 16이 되고 16에 \*2**를 하면 우리가 원하는 세그먼트 트리의 크기를 구할 수 있다. 



이 과정이 귀찮다면 그냥 **N \* 4**를하면(여기서는 48이 세그먼트 트리 크기가 될 것이다.)

메모리는 조금 더 먹지만, 편리하게 이용할 수 있다.



C++의 경우, h를 구하는 방법

```c++
int h = (int)ceil(log2(n));
int tree_size = (1 << (h+1));  
```

이렇게 나타낼 수 있는데 ceil은 올림을 하겠다는 의미이고, log2N에서 도출되는 값을 올림한 값을 h에 저장한다.

즉 log2(12) = 3.xxx이고 올림한 4를 h에 저장한다.



1 << (4+1) = 1 << 5 = 32가 결국 tree_size가 된다.



Java의 경우, h를 구하는 방법

```java
int h = (int)Math.ceil(Math.log(n)/Math.log(2));
int[] tree = new int[(int) Math.pow(2, h+1)];
```











출처: https://www.crocus.co.kr/648 [Crocus]

