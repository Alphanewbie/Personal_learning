## 백준 2169번 풀이

https://www.acmicpc.net/problem/2169

### 문제

*NASA에서는 화성 탐사를 위해 화성에 무선 조종 로봇을 보냈다. 실제 화성의 모습은 굉장히 복잡하지만, 로봇의 메모리가 얼마 안 되기 때문에 지형을 N×M 배열로 단순화 하여 생각하기로 한다.*

*지형의 고저차의 특성상, 로봇은 움직일 때 배열에서 왼쪽, 오른쪽, 아래쪽으로 이동할 수 있지만, 위쪽으로는 이동할 수 없다. 또한 한 번 탐사한 지역(배열에서 하나의 칸)은 탐사하지 않기로 한다.*

*각각의 지역은 탐사 가치가 있는데, 로봇을 배열의 왼쪽 위 (1, 1)에서 출발시켜 오른쪽 아래 (N, M)으로 보내려고 한다. 이때, 위의 조건을 만족하면서, 탐사한 지역들의 가치의 합이 최대가 되도록 하는 프로그램을 작성하시오.*



### 입력

*첫째 줄에 N, M(1≤N, M≤1,000)이 주어진다. 다음 N개의 줄에는 M개의 수로 배열이 주어진다. 배열의 각 수는 절댓값이 100을 넘지 않는 정수이다. 이 값은 그 지역의 가치를 나타낸다.*

### 출력

*첫째 줄에 최대 가치의 합을 출력한다.*

***



### 풀이

 처음엔 감이 잡히지 않아서 각 테이블로 갈 수 있는 루트의 경우의 수부터 세기 시작했다.

일단은 작은 경우부터

n=2, m=2

| 1 | 1 |
| 2 | 2 |

n=3, m=2

| 1 | 1 |
| 2 | 2 |
| 4 | 4 |

n=2, m=3

| 1 | 1 | 1 |
| 3 | 3 | 3 |

n=3, m=3

| 1 | 1 | 1 |
| 3 | 3 | 3 |
| 9 | 9 | 9 |

n줄의 각 항목의 접근을 하기 위한 경우의 수는 위의 모든 경우의 수를 더하는 경우와 똑같다.

이건 경우의 수일 뿐 도움이 되진 않았지만, 일단 어떻게 하는지 감이 잡히기 시작했다.



예를 들면 (2,1)의 위치를 가려면

\| > | ∨ |   |

\|ㅇ| <  |   |

---

\| > | > | ∨ |

\|ㅇ| < | <  |

---

\| ∨ |    |    |

\|ㅇ |    |    |

같은 경우 밖에 없는데, 즉 바로 위에서 내려오거나, 아니면 오른쪽으로 쭉 갔다가 왼쪽부터 내려오거나 같은 경우 밖에 없었다. 한 방향을 잡으면 쭉 잡고 달려오는 경우이다.



즉 쉽게 말해 , 한 줄의 각 왼쪽에서 오는 것 오른쪽에서 오는 것 의 값들의 각자 최대 값을 하면 된다

각,  위치의 값은 위에서 바로 온 것, 옆에서 바로 온것, 아니면 위에서 바로 온 것 3중 하나이다.



일단 **베이스 케이스**

첫번째 줄인 경우, 이거는 그냥 그냥 오른쪽으로 가는 경우니 쭉 채우면 된다.

```sudo
dp[1][1] <- matrix[1][1]
for i=2...m
	dp[1][j] <- matrix[1][j]+ dp[1][j-1]
```



**점화식**

각 각 방향에서 온 것을 찾으면 된다. 단, 한 줄을 통째로 계산해야 하니 임시로 만들 2줄을 만든다. 왜 두줄이냐 하면 왼쪽으로 할지 오른쪽에서 할지의 두 줄이다.



그리고 각 줄의 위부터 내려오는 경우, 왼쪽에서 오는 경우, 오른쪽에서 오는 경우 각각 최대값을 구한다.

```sudo
for i=2...n
	temp[0][0] <- dp[i-1][1];
    for j = 1.... m
		temp[0][j] <- max(temp[0][j-1], dp[i-1][j])+ matrix[i][j];

    temp[1][m+1] <- dp[i-1][m];
    for j = m.... 1  : -1 
		temp[1][j] <- max(temp[1][j+1], dp[i-1][j]) + matrix[i][j];
	for j = 1... m
         dp[i][j] =<- max(temp[0][j], temp[1][j]);
```







### 전체 코드

```java
import java.util.Scanner;
 
public class Main {
 
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
         
        int[][] matrix = new int[n+1][m+1];
        int[][] dp = new int[n+1][m+1];
        int[][] temp = new int[2][m+2];
         
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= m; j++){
                matrix[i][j] = in.nextInt();
            }
        }
         
        dp[1][1] = matrix[1][1];
         
        for(int j = 2; j <= m; j++) dp[1][j] = matrix[1][j]+ dp[1][j-1];
         
        for(int i = 2; i <= n; i++) {
             
            temp[0][0] = dp[i-1][1];
            for(int j = 1; j <= m; j++) {
                temp[0][j] = Math.max(temp[0][j-1], dp[i-1][j])+ matrix[i][j];
            }
             
            temp[1][m+1] = dp[i-1][m];
            for(int j = m; j >= 1; j--) {
                temp[1][j] = Math.max(temp[1][j+1], dp[i-1][j]) + matrix[i][j];
            }
             
            for(int j = 1; j <= m; j++) {
                dp[i][j] = Math.max(temp[0][j], temp[1][j]);
            }
        }
//        for(int i = 1; i <= n; i++) {
//            for(int j = 1; j <= m; j++){
//                System.out.printf("%4d",dp[i][j]);
//            }
//            System.out.println();
//        }
        
        System.out.println(dp[n][m]);
         
        in.close();
    }
 
}
```

