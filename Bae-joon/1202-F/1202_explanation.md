## 백준 1202번 풀이

https://www.acmicpc.net/problem/1202

### 문제

*세계적인 도둑 상덕이는 보석점을 털기로 결심했다.*

*상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 Mi와 가격 Vi를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 Ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.*

*상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.*

### 입력

*첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)*

*다음 N개 줄에는 각 보석의 정보 Mi와 Vi가 주어진다. (0 ≤ Mi, Vi ≤ 1,000,000)*

*다음 K개 줄에는 가방에 담을 수 있는 최대 무게 Ci가 주어진다. (1 ≤ Ci ≤ 100,000,000)*

*모든 숫자는 양의 정수이다.*

### 출력

*첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.*

***



### 풀이

일단 처음에는 문제를 가방이 여러 개가 있고 이 가방마다 여러개의 물건을 넣을 수 있는 문제인 줄 알았다.

그래서 처음에 풀때는 [12865](https://www.acmicpc.net/problem/12865)같은 문제일 줄 알고 각각의 가방에 넣을 수 있는 최대 값을 구하려고 했다.

하지만 이런 경우에는 가방에 넣은 물건들을 제외 시켜줘야 하는 일이 있었다.



그래서 문제가 너무 어려워서 다시 읽어보니 가방에 보석을 하나씩 넣는 문제 라는 것을 알고 다시 풀어 보기로 했다.

일단 이 문제에서 중요한 것은 4가지가 있다.

1. 보석의 가치
2. 보석의 무게
3. 가방의 용량
4. 가방의 수

일단 가방의 수는 12865 처럼 가방 하나 씩만 꺼내서 푸는 걸로 일단 가방을 고려하지 않기로 했다.

그리고 무게도 이미 사전에 정해져 있는거니 문제를 알아보기 쉽게 각각 직접적인 연관이 있는 가방의 용량과, 보석의 무게를 기준으로 각각 항목으로 정렬을 했다.

하지만 여기서 문제가 생겼는데

|      | [1,65] | [2,99] | [10,23] |
| ---- | ------ | ------ | ------- |
| 2    | 65     | 99     | 99      |
| 10   |        |        |         |

일단 1번의 경우엔 이렇게 하는 걸 알았지만

2번 부터 고민이 생기기 시작했다.

|      | [1,65] | [2,99] | [10,23] |
| ---- | ------ | ------ | ------- |
| 2    | 65     | 99     | 99      |
| 10   | 0      | 65     | 65      |

일단 첫 번째 칸을 보려면 위 칸을 봐야 한다. 위 칸이 이미 65를 가지고 있으니 0으로 채운다. 하지만 위에서 65를 버렸으니 전 칸의 65를 가져 와서 채운다.

이 경우에는 문제가 제대로 풀리긴 하지만,  만약 하나를 더 가져간다고 해보자

|      | [1,65] | [2,99] | [10,23] |
| ---- | ------ | ------ | ------- |
| 2    | 65     | 99     | 99      |
| 10   | 0      | 65     | 65      |
| 13   | 0      | 0      | 23      |

13의 경우에는 65는 위에서 0이니 0을 그대로 가져간다. 99는 위가 99 가 아니니 이미 위에서 가져간다고 치고 넘어간다. 이제 23의 경우에는 앞의 배열을 이미 다 가져갔으니 23을 채운다.



즉, 이런 방식으로 푸는 문제인 것을 알 수 있었다.

일단 베이스케이스 첫번째 케이스는 가방이 용량이 허용하는 한에서 가장 큰 물건을 넣는다.

```pseudocode
for i=0 ... n :
	if(i==0) :
		dp[0][0] = item[0].val
	else :
		if item[i].weight <= nowBag
			dp[0][i] = MAX(dp[0][i-1],item[i].val)
		else
			dp[0][i] = dp[0][i-1]
```



이제 점화식이다

```pseudocode
for j = 1 ...k :
	for i=0 ... n :
		gemList.add(item[i].val)
		if(dp[j][i]!=0)
			젬 리스트에서 위에 있는 잼의 가치가 같은 것 이후로 전부 버린다.
			그리고 현재의 다음 j부터 현재의 잼의 가치를 넣는다.
			그 다음 부터는
			dp[0][i] = MAX(dp[0][i-1],item[i].val)
```



이렇게 하자니 너무 어려웠다.

그래서 일차원 배열로 스택에 넣는 것도 생각해보고

스택으로 역순으로 빼는 것도 고려해 봤지만,

어느쪽도 에러가 나서 gemList에 어떻게 넣고 삭제하느냐에 따라 문제를 해결하는 방법을 알아야 됬고.

아니면, 아예 쥬얼을 배열에서 삭제하는 방식으로 해야 된다고 생각했다.



우선순위 큐를 이용하고, 이런 식으로 이중 배열을 하는 것이 아니라 아예 일차원 배열로 우선순위 큐를 이용해 하나하나 버리는 방식으로 하면 된다는 것을 알았다.

### 전체 코드

```python
import sys
import heapq

input = sys.stdin.readline

def knap(k, item, backpack) :
    total_value = 0
    capable_gem = []

    for _ in range(k):
        capacity = heapq.heappop(backpack)

        while item and capacity >= item[0][0]:
            [_, value] = heapq.heappop(item)
            heapq.heappush(capable_gem, -value)

        if capable_gem:
            total_value -= heapq.heappop(capable_gem)
        elif not item:
            break

    return total_value

if __name__ == "__main__" :

    (n, k) = map(int, input().strip().split())

    item = []
    backpack = []

    for _ in range(n) :
        m, v = map(int,input().split())
        heapq.heappush(item,[m, v])

    for _ in range(k) :
        c = int(input())
        heapq.heappush(backpack,c)

    print(knap(k, item, backpack))

# 출처 : https://claude-u.tistory.com/343
```





### 시사점

- 우선순위 큐에 대한 자료 구조 다시 한번 정리하자.

